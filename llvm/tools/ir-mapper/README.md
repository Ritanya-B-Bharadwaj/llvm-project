# LLVM Source-to-IR annotator

This directory has the source code for a tool that maps IR code to the corresponding source code line that generated it, and a tool that uses GenAI to explain the generated IR code in plain English.

The directory structure for these tools is as follows:
```
llvm-project
└── llvm
    └── tools
        └── ir-mapper
            └── examples
                └── test.cpp
                └── out.ll
                └── out.md
                └── out_explained.md
            └── IRMapper.cpp
            └── mapping_explainer.py
            └── CMakeLists.txt
            └── README.md (this file)
...
```
The `examples` subfolder contains some sample files that can be used with the provided tools and their outputs.

## Building
To build these tools, 
1. Run `ninja ir-mapper` (for the source-to-IR annotator CLI tool)
2. Run `pip install groq` (for the GenAI explainer)
- The `groq` package may be installed on a venv or globally.
- To use the GenAI explainer, ensure that the `GROQ_API_KEY` environment variable is set.
- After building `ir-mapper` with ninja, the CLI tool becomes available at `build/bin/ir-mapper`.

## Running

`ir-mapper` usage: `ir-mapper in.cpp -ol annotatedllfile.ll -om markdownfile.md` 
- `in.cpp`: Source C++ file path
- `annotatedllfile.ll`: Output annotated LLVM instruction file path
- `markdownfile.md`: Output markdown file with Source-IR mapping

`mapping_explaineer.py` usage: `python mapping_explainer.py inputmd.md outputmd.md`
- `inputmd.md`: Markdown file with Source-IR mapping (generated by `ir-mapper`)
- `outputmd.md`: Markdown file with plain English explanation of IR code, generated by AI.

### Example usage: 
(assume the current working directory is `llvm/tools/ir-mapper`.)
```
../../../build/bin/ir-mapper ./examples/test.cpp -ol ./examples/out.ll -om ./examples/out.md
python mapping_explainer.py ./examples/out.md ./examples/out_explained.md

```
These commands generate the following output files in the `llvm/tools/ir-mapper/examples` directory:
- `out.ll` - The annotated LLVM IR code file
- `out.md` - The markdown file with the mapped source code and IR code lines.
- `out_explained.md` - The markdown file that explains the IR code lines from `out.md`.

### Sample Input and Outputs

The following `test.cpp` file generates the following output files:
`test.cpp`
```cpp
int add(int a, int b) {
    return a + b;
}

int main() {
    int c = add(3, 4);
    return 0;
}
```

`out.ll`
```llvm
; ./examples/test.cpp:2 -     return a + b;
  %5 = load i32, ptr %3, align 4, !dbg !20
; ./examples/test.cpp:2 -     return a + b;
  %6 = load i32, ptr %4, align 4, !dbg !21
; ./examples/test.cpp:2 -     return a + b;
  %7 = add nsw i32 %5, %6, !dbg !22
; ./examples/test.cpp:2 -     return a + b;
  ret i32 %7, !dbg !23
; ./examples/test.cpp:6 -     int c = add(3, 4);
  %3 = call noundef i32 @_Z3addii(i32 noundef 3, i32 noundef 4), !dbg !18
; ./examples/test.cpp:6 -     int c = add(3, 4);
  store i32 %3, ptr %2, align 4, !dbg !17
; ./examples/test.cpp:7 -     return 0;
  ret i32 0, !dbg !19
```

`out.md`
````md
### ./examples/test.cpp

#### Line 2
Source code: `    return a + b;`

Mapped IR code:
```llvm
  %5 = load i32, ptr %3, align 4, !dbg !20
  %6 = load i32, ptr %4, align 4, !dbg !21
  %7 = add nsw i32 %5, %6, !dbg !22
  ret i32 %7, !dbg !23
```

#### Line 6
Source code: `    int c = add(3, 4);`

Mapped IR code:
```llvm
  %3 = call noundef i32 @_Z3addii(i32 noundef 3, i32 noundef 4), !dbg !18
  store i32 %3, ptr %2, align 4, !dbg !17
```

#### Line 7
Source code: `    return 0;`

Mapped IR code:
```llvm
  ret i32 0, !dbg !19
```
````

`out_explained.md`
````md
### Line 1: `return a + b;`

**LLVM IR Block:**
```llvm
### ./examples/test.cpp


  %5 = load i32, ptr %3, align 4, !dbg !20
  %6 = load i32, ptr %4, align 4, !dbg !21
  %7 = add nsw i32 %5, %6, !dbg !22
  ret i32 %7, !dbg !23

```

**Explanation:**

Here's what this block of LLVM IR does:

This block takes two numbers (`a` and `b`) from memory, adds them up, and then returns the result.

Here's how it relates to the source line: 

- The `load` instructions fetch the values of `a` and `b` from memory.
- The `add` instruction performs the actual addition of `a` and `b`.
- The `ret` instruction returns the result of the addition, which is the sum of `a` and `b`.

---

### Line 2: `int c = add(3, 4);`

**LLVM IR Block:**
```llvm

  %3 = call noundef i32 @_Z3addii(i32 noundef 3, i32 noundef 4), !dbg !18
  store i32 %3, ptr %2, align 4, !dbg !17

```

**Explanation:**

Here's what this LLVM IR block does:

This block of code is equivalent to the C++ source line `int c = add(3, 4);`. 

Here's what happens step by step:

1. The `add` function is called with arguments 3 and 4. The result of this function call is stored in a temporary variable (let's call it `%3`).

2. The value stored in `%3` (which is the result of `add(3, 4)`) is then stored in a memory location (let's call it `%2`). This memory location is where the variable `c` from the C++ source line is stored. 

In other words, this IR block is doing exactly what the C++ source line: calling the `add` function with 3 and 4, and then storing the return value of that function in a variable `c`.

---

### Line 3: `return 0;`

**LLVM IR Block:**
```llvm

  ret i32 0, !dbg !19

```

**Explanation:**

This LLVM IR block returns an integer value of 0 to the caller. 

In other words, when the program reaches this point, it will stop executing and return 0 as the result. This IR block directly corresponds to the C++ source line "return 0;" which also returns 0 to the caller.

---
````
