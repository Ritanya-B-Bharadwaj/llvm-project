<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AST Annotator & Compiler Guide</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>

<body>
    <div class="container">
        <div class="header">
            <div class="header-content">
                <h1> Source Code to AST Annotator</h1>
            </div>
        </div>
        <nav class="nav">
            <ul class="nav-list">
                <li><button class="nav-link" data-section="phases">Compiler Overview</button></li>
                <li><button class="nav-link" data-section="ast-deep-dive">AST</button></li>
                <li><button class="nav-link" data-section="examples">Examples</button></li>
                <li><button class="nav-link active" data-section="annotator">AST Annotator</button></li>
                
                
            </ul>
        </nav>
        <div class="content">
            <!-- AST Annotator Section -->
            <section id="section-annotator" class="section visible">
                <div class="controls" style="margin-bottom:24px;">
                    <div class="control-group">
                        <label for="filterSelect">Filter Level:</label>
                        <select id="filterSelect">
                            <option value="clean">Clean (Recommended)</option>
                            <option value="minimal">Minimal (Essential Only)</option>
                            <option value="all">All Nodes</option>
                        </select>
                        <button id="analyzeBtn" class="analyze-btn">Analyze Code</button>
                        <button id="clearBtn" type="button" class="analyze-btn"
                            style="background:#64748b;">Clear</button>
                    </div>
                </div>
                <div style="display: flex; flex-wrap: wrap; gap: 30px;">
                    <div style="flex:1; min-width:320px;">
                        <h3 style="margin-bottom:10px;">Enter Your C/C++ Code</h3>
                        <textarea id="codeInput" class="code-input"
                            placeholder="Enter your C/C++ code here..."></textarea>
                    </div>
                    <div style="flex:1; min-width:320px;">
                        <h3 style="margin-bottom:10px;">Annotated Output</h3>
                        <div class="analysis-results" id="resultsContainer">
                            <div class="empty-state" id="initialEmptyState">
                                <h3>Ready to analyze!</h3>
                                <p>Enter your C/C++ code and click "Analyze Code" to see the AST nodes.</p>
                            </div>
                            <div class="panel-content" id="codePanel"></div>
                            <div style="margin-top:20px;">
                                <h4>AST Tree View</h4>
                                <div id="astTreeContainer" class="ast-tree"></div>
                            </div>

                        </div>
                    </div>
            </section>

            <!-- Phases Section -->
            <section id="section-phases" class="section">
                <h2 class="section-title">What is a Compiler?</h2>
                <p class="intro-text">
                    A compiler is a sophisticated program that translates high-level source code into machine code or
                    intermediate representations. This process involves multiple phases, each with specific
                    responsibilities in the translation pipeline. Understanding these phases is crucial for effective
                    code analysis, optimization, and debugging.
                </p>
                <h2 class="section-title">Phases of a Compiler</h2>
                <div class="phases-overview">
                    <div class="phase-card">
                        <div class="phase-number">1</div>
                        <h3 class="phase-title">Lexical Analysis</h3>
                        <p class="phase-description">
                            Breaks source code into meaningful tokens (keywords, identifiers, operators, literals). The
                            lexer removes whitespace and comments while identifying basic language elements.
                        </p>
                        <div class="phase-examples">
                            <h4>Example Tokens:</h4>
                            <p><code>int x = 42;</code> → <code>INT</code>, <code>IDENTIFIER(x)</code>,
                                <code>ASSIGN</code>, <code>NUMBER(42)</code>, <code>SEMICOLON</code>
                            </p>
                        </div>
                    </div>
                    <div class="phase-card">
                        <div class="phase-number">2</div>
                        <h3 class="phase-title">Syntax Analysis</h3>
                        <p class="phase-description">
                            Analyzes token sequences to ensure they follow the language's grammar rules. Constructs a
                            parse tree or directly builds an Abstract Syntax Tree (AST).
                        </p>
                        <div class="phase-examples">
                            <h4>Checks Grammar Rules:</h4>
                            <p>Validates expressions, statements, declarations, and program structure according to C/C++
                                syntax rules.</p>
                        </div>
                    </div>
                    <div class="phase-card">
                        <div class="phase-number">3</div>
                        <h3 class="phase-title">Semantic Analysis</h3>
                        <p class="phase-description">
                            Performs type checking, scope resolution, and symbol table management. Ensures the program's
                            meaning is correct beyond just syntax.
                        </p>
                        <div class="phase-examples">
                            <h4>Semantic Checks:</h4>
                            <p>Type compatibility, variable declarations, function signatures, operator overloading
                                resolution.</p>
                        </div>
                    </div>
                    <div class="phase-card">
                        <div class="phase-number">4</div>
                        <h3 class="phase-title">Intermediate Code Generation</h3>
                        <p class="phase-description">
                            Converts the AST into an intermediate representation (IR) that's easier to optimize and
                            target to different architectures.
                        </p>
                        <div class="phase-examples">
                            <h4>IR Examples:</h4>
                            <p>Three-address code, Static Single Assignment (SSA), LLVM IR, or custom intermediate
                                representations.</p>
                        </div>
                    </div>
                    <div class="phase-card">
                        <div class="phase-number">5</div>
                        <h3 class="phase-title">Code Optimization</h3>
                        <p class="phase-description">
                            Improves code efficiency through various optimization techniques without changing program
                            semantics.
                        </p>
                        <div class="phase-examples">
                            <h4>Optimization Types:</h4>
                            <p>Dead code elimination, constant folding, loop optimization, register allocation,
                                inlining.</p>
                        </div>
                    </div>
                    <div class="phase-card">
                        <div class="phase-number">6</div>
                        <h3 class="phase-title">Code Generation</h3>
                        <p class="phase-description">
                            Translates optimized intermediate code into target machine code or assembly language
                            specific to the target architecture.
                        </p>
                        <div class="phase-examples">
                            <h4>Target Outputs:</h4>
                            <p>Assembly code, machine code, bytecode, or other executable formats for the target
                                platform.</p>
                        </div>
                    </div>
                </div>
            </section>
            <!-- Examples Section -->
            <section id="section-examples" class="section">
                <h2 class="section-title">AST Examples</h2>
                <div class="ast-examples">
                    <h3>Simple Expression Analysis</h3>
                    <pre><code>int result = a + b * 2;</code></pre>
                    <h3>Control Flow Analysis</h3>
                    <pre><code>if (x > 0) {
    cout << "Positive";
} else {
    cout << "Non-positive";
}</code></pre>
                    <h3>AST Node Categories</h3>
                    <table class="comparison-table">
                        <thead>
                            <tr>
                                <th>Category</th>
                                <th>Description</th>
                                <th>Examples</th>
                                <th>Use Cases</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Declarations</td>
                                <td>Define entities in the program</td>
                                <td>VarDecl, FunctionDecl, ClassDecl</td>
                                <td>Symbol table construction, scope analysis</td>
                            </tr>
                            <tr>
                                <td>Statements</td>
                                <td>Executable units of code</td>
                                <td>IfStmt, WhileStmt, ReturnStmt</td>
                                <td>Control flow analysis, code generation</td>
                            </tr>
                            <tr>
                                <td>Expressions</td>
                                <td>Compute values</td>
                                <td>BinaryOperator, CallExpr, DeclRefExpr</td>
                                <td>Type checking, optimization</td>
                            </tr>
                            <tr>
                                <td>Types</td>
                                <td>Represent data types</td>
                                <td>BuiltinType, PointerType, RecordType</td>
                                <td>Type analysis, memory layout</td>
                            </tr>
                            <tr>
                                <td>Literals</td>
                                <td>Constant values</td>
                                <td>IntegerLiteral, StringLiteral, FloatingLiteral</td>
                                <td>Constant folding, initialization</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="ast-examples ast-clang">
                    <h3>Working with Clang AST</h3>
                    <pre><code># Generate AST dump using Clang
clang -Xclang -ast-dump -fsyntax-only example.cpp

# Generate AST in JSON format
clang -Xclang -ast-dump=json -fsyntax-only example.cpp

# View specific AST node types
clang -Xclang -ast-dump -Xclang -ast-dump-filter=main example.cpp
</code></pre>
                </div>
                <h3>AST Traversal Patterns</h3>
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Pattern</th>
                            <th>Description</th>
                            <th>Use Case</th>
                            <th>Implementation</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Visitor Pattern</td>
                            <td>Visit each node type with specific handlers</td>
                            <td>Type-specific processing</td>
                            <td>RecursiveASTVisitor in Clang</td>
                        </tr>
                        <tr>
                            <td>Depth-First Search</td>
                            <td>Process children before siblings</td>
                            <td>Dependency analysis</td>
                            <td>Recursive traversal</td>
                        </tr>
                        <tr>
                            <td>Breadth-First Search</td>
                            <td>Process all nodes at same level</td>
                            <td>Level-based analysis</td>
                            <td>Queue-based traversal</td>
                        </tr>
                        <tr>
                            <td>Matcher-Based</td>
                            <td>Find nodes matching specific patterns</td>
                            <td>Code search and transformation</td>
                            <td>ASTMatchers library</td>
                        </tr>
                    </tbody>
                </table>
                <div class="ready-to-explore">
                    <h2>Ready to Explore?</h2>
                    <p>
                        Now that you understand compiler phases and AST fundamentals, try analyzing your own C/C++ code
                        with our interactive AST annotator tool.
                    </p>
                </div>
            </section>
            <!-- AST Deep Dive Section -->
            <section id="section-ast-deep-dive" class="section ast-deep-dive">
                <div class="ast-content">
                    <h2 class="ast-title">Abstract Syntax Tree (AST)</h2>
                    <div class="ast-grid">
                        <div class="ast-section">
                            <h3>What is an AST?</h3>
                            <p>An Abstract Syntax Tree is a hierarchical representation of the syntactic structure of
                                source code. Unlike parse trees, ASTs abstract away syntactic details and focus on the
                                logical structure of the program.</p>
                            <p>Each node in an AST represents a construct occurring in the source code, with the tree
                                structure showing the relationships between different parts of the program.</p>
                        </div>
                        <div class="ast-section">
                            <h3>AST vs Parse Tree</h3>
                            <p><strong>Parse Tree:</strong> Contains all syntactic details including punctuation,
                                keywords, and intermediate grammar rules.</p>
                            <p><strong>AST:</strong> Eliminates redundant information and focuses on semantic meaning,
                                making it more compact and easier to work with for analysis and code generation.</p>
                        </div>
                        <div class="ast-section">
                            <h3>AST Node Types</h3>
                            <p><strong>Declaration Nodes:</strong> Variables, functions, classes, namespaces</p>
                            <p><strong>Statement Nodes:</strong> If statements, loops, expression statements, return
                                statements</p>
                            <p><strong>Expression Nodes:</strong> Binary operations, function calls, literals,
                                identifiers</p>
                            <p><strong>Type Nodes:</strong> Built-in types, user-defined types, pointer types, array
                                types</p>
                        </div>
                        <div class="ast-section">
                            <h3>Clang AST Features</h3>
                            <p>Clang provides one of the most detailed and well-structured AST implementations for
                                C/C++. It includes rich type information, source location data, and comprehensive node
                                hierarchies.</p>
                            <p>The Clang AST preserves enough information to reconstruct the original source code while
                                providing easy access to semantic information.</p>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </div>
    <script>
        // Navigation logic
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', function () {
                document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));
                this.classList.add('active');
                const section = this.getAttribute('data-section');
                document.querySelectorAll('.section').forEach(sec => sec.classList.remove('visible'));
                document.getElementById('section-' + section).classList.add('visible');
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        });

        // AST Annotator logic
        class ASTAnnotator {
            constructor() {
                this.initializeElements();
                this.bindEvents();
                this.loadSampleCodeOnce();
            }
            initializeElements() {
                this.codeInput = document.getElementById('codeInput');
                this.filterSelect = document.getElementById('filterSelect');
                this.analyzeBtn = document.getElementById('analyzeBtn');
                this.clearBtn = document.getElementById('clearBtn');
                this.resultsContainer = document.getElementById('resultsContainer');
                this.codePanel = document.getElementById('codePanel');
            }
            bindEvents() {
                this.analyzeBtn.addEventListener('click', () => this.analyzeCode());
                this.clearBtn.addEventListener('click', () => this.clearResults());
                this.filterSelect.addEventListener('change', () => {
                    if (this.codeInput.value.trim()) this.analyzeCode();
                });
                this.codeInput.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.key === 'Enter') this.analyzeCode();
                });
            }
            loadSampleCodeOnce() {
                if (!this.codeInput.value.trim()) {
                    this.codeInput.value = `#include <iostream>
int main() {
    int x = 42;
    if (x > 0) {
        std::cout << "Positive number" << std::endl;
    }
    return 0;
}`;
                }
            }
            async analyzeCode() {
                const code = this.codeInput.value.trim();
                if (!code) {
                    alert('Please enter some C/C++ code to analyze.');
                    return;
                }
                this.showLoading();
                this.analyzeBtn.disabled = true;
                try {
                    const response = await fetch('/annotate', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ code: code, filter: 'clean', detailed: false })
                    });
                    const result = await response.json();
                    if (result.success) {
                        this.displayResults(result);
                    } else {
                        this.showError(result.error || 'Analysis failed');
                    }
                } catch (error) {
                    this.showError('Network error: ' + error.message);
                } finally {
                    this.analyzeBtn.disabled = false;
                }
            }
            showLoading() {
                this.resultsContainer.style.display = 'block';
                this.codePanel.innerHTML = '<div class="loading">Analyzing code...</div>';
            }
            showError(message) {
                this.resultsContainer.style.display = 'block';
                this.codePanel.innerHTML = `<div class="error-message">❌ ${message}</div>`;
            }
            displayResults(result) {
                const lines = Array.isArray(result.lines) ? result.lines : [];
                let html = '';
                const initialEmptyState = document.getElementById('initialEmptyState');

                if (lines.length > 0 && initialEmptyState) {
                    initialEmptyState.style.display = 'none';
                }

                if (!lines.length) {
                    html = '<div class="empty-state"><h3>No AST annotations found</h3><p>Try analyzing different code or adjusting the filter level.</p></div>';
                } else {
                    // Hide empty state by not including it when we have results
                    lines.forEach(line => {
                        html += `
                            <div class="line-annotation">
                                <div class="line-header">
                                    <span class="line-number">${line.number}</span>
                                    <span class="source-code">${this.escapeHtml(line.code)}</span>
                                </div>
                                ${line.inline_nodes ? `<div class="inline-nodes">${this.escapeHtml(line.inline_nodes)}</div>` : ''}
                                ${line.annotations && line.annotations.length ? `
                                    <div class="annotations-list">
                                        ${line.annotations.map(ann => `
                                            <span class="annotation-tag ${ann.category}" title="${this.escapeHtml(ann.description)}">${this.escapeHtml(ann.kind)}</span>
                                        `).join('')}
                                    </div>
                                ` : ''}
                            </div>
                        `;
                    });
                }

                this.codePanel.innerHTML = html;
                this.resultsContainer.style.display = 'block';

                // Hide the initial empty state in the results container
                const emptyStateInResults = this.resultsContainer.querySelector('.empty-state');
                if (emptyStateInResults && lines.length > 0) {
                    emptyStateInResults.style.display = 'none';
                }

                if (result.tree) {
                    const treeHtml = renderASTTree(result.tree);
                    document.getElementById('astTreeContainer').innerHTML = treeHtml;
                } else {
                    document.getElementById('astTreeContainer').innerHTML = '<em>No AST tree available</em>';
                }

            }
            clearResults() {
                const initialEmptyState = document.getElementById('initialEmptyState');
                if (initialEmptyState) {
                    initialEmptyState.style.display = 'flex';
                }
                this.codePanel.innerHTML = '';
                this.codeInput.value = '';
                this.filterSelect.value = 'clean';
                this.codeInput.focus();
            }
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }

        // Helper function outside the class
        function renderASTTree(node, depth = 0) {
            if (!node || typeof node !== 'object') return '';

            const indent = '&nbsp;'.repeat(depth * 4);
            const kind = node.kind || 'Unknown';
            const name = node.name || '';
            const label = name ? `${kind} (${name})` : kind;

            let html = `<div class="tree-node" style="margin-left:${depth * 16}px">
                            <details open>
                                <summary><span class="tree-label">${label}</span></summary>`;

            // Recursively render children
            if (Array.isArray(node.inner)) {
                for (const child of node.inner) {
                    html += renderASTTree(child, depth + 1);
                }
            }

            html += `</details></div>`;
            return html;
        }

        document.addEventListener('DOMContentLoaded', () => {
            new ASTAnnotator();
        });
    </script>
</body>

</html>