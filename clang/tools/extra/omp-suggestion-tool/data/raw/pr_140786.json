{
    "number": 140786,
    "title": "[OpenMP][GPU][FIX] Enable generic barriers in single threaded contexts",
    "body": "The generic GPU barrier implementation checked if it was the main thread in generic mode to identify single threaded regions. This doesn't work since inside of a non-active (=sequential) parallel, that thread becomes the main thread of a team, and is not the main thread in generic mode. At least that is the implementation of the APIs today.\r\n\r\nTo identify single threaded regions we now check the team size explicitly.\r\n\r\nThis exposed three other issues; one is, for now, expected and not a bug, the second one is a bug and has a FIXME in the\r\nsingle_threaded_for_barrier_hang_1.c file, and the final one is also benign as described in the end.\r\n\r\nThe non-bug issue comes up if we ever initialize a thread state. Afterwards we will never run any region in parallel. This is a little conservative, but I guess thread states are really bad for performance anyway.\r\n\r\nThe bug comes up if we optimize single_threaded_for_barrier_hang_1 and execute it in Generic-SPMD mode. For some reason we loose all the updates to b. This looks very much like a compiler bug, but could also be another logic issue in the runtime. Needs to be investigated.\r\n\r\nIssue number 3 comes up if we have nested parallels inside of a target region. The clang SPMD-check logic gets confused, determines SPMD (which is fine) but picks an unreasonable thread count. This is all benign, I think, just weird:\r\n\r\n```\r\n  #pragma omp target teams\r\n  #pragma omp parallel num_threads(64)\r\n  #pragma omp parallel num_threads(10)\r\n  {}\r\n```\r\nWas launched with 10 threads, not 64.",
    "created_at": "2025-05-20T19:09:17Z",
    "merged_at": "2025-05-21T02:33:54Z",
    "user": "jdoerfert",
    "files": [
        "offload/DeviceRTL/src/Synchronization.cpp",
        "offload/test/offloading/single_threaded_for_barrier_hang_1.c",
        "offload/test/offloading/single_threaded_for_barrier_hang_2.c"
    ],
    "commits": [
        "[OpenMP][GPU][FIX] Enable generic barriers in single threaded contexts\n\nThe generic GPU barrier implementation checked if it was the main thread\nin generic mode to identify single threaded regions. This doesn't work\nsince inside of a non-active (=sequential) parallel, that thread becomes\nthe main thread of a team, and is not the main thread in generic mode.\nAt least that is the implementation of the APIs today.\n\nTo identify single threaded regions we now check the team size\nexplicitly.\n\nThis exposed three other issues; one is, for now, expected and not a bug,\nthe second one is a bug and has a FIXME in the\nsingle_threaded_for_barrier_hang_1.c file, and the final one is also\nbenign as described in the end.\n\nThe non-bug issue comes up if we ever initialize a thread state.\nAfterwards we will never run any region in parallel. This is a little\nconservative, but I guess thread states are really bad for performance\nanyway.\n\nThe bug comes up if we optimize single_threaded_for_barrier_hang_1 and\nexecute it in Generic-SPMD mode. For some reason we loose all the\nupdates to b. This looks very much like a compiler bug, but could also\nbe another logic issue in the runtime. Needs to be investigated.\n\nIssue number 3 comes up if we have nested parallels inside of a target\nregion. The clang SPMD-check logic gets confused, determines SPMD (which\nis fine) but picks an unreasonable thread count. This is all benign, I\nthink, just weird:\n\n```\n  #pragma omp target teams\n  #pragma omp parallel num_threads(64)\n  #pragma omp parallel num_threads(10)\n  {}\n```\n\nWas launched with 10 threads, not 64."
    ]
}