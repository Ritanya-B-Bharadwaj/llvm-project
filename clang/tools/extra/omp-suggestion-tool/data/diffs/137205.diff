diff --git a/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h b/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h
index a483b0a6cfdc5..ffc0fd0a0bdac 100644
--- a/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h
+++ b/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h
@@ -686,6 +686,16 @@ class OpenMPIRBuilder {
                                     Value *IfCondition,
                                     omp::Directive CanceledDirective);
 
+  /// Generator for '#omp cancellation point'
+  ///
+  /// \param Loc The location where the directive was encountered.
+  /// \param CanceledDirective The kind of directive that is cancled.
+  ///
+  /// \returns The insertion point after the barrier.
+  InsertPointOrErrorTy
+  createCancellationPoint(const LocationDescription &Loc,
+                          omp::Directive CanceledDirective);
+
   /// Generator for '#omp parallel'
   ///
   /// \param Loc The insert and source location description.
diff --git a/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp b/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
index 8dc6ea175e0dc..3ab44cbf730e5 100644
--- a/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
+++ b/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp
@@ -1118,6 +1118,57 @@ OpenMPIRBuilder::createCancel(const LocationDescription &Loc,
   return Builder.saveIP();
 }
 
+OpenMPIRBuilder::InsertPointOrErrorTy
+OpenMPIRBuilder::createCancellationPoint(const LocationDescription &Loc,
+                                         omp::Directive CanceledDirective) {
+  if (!updateToLocation(Loc))
+    return Loc.IP;
+
+  // LLVM utilities like blocks with terminators.
+  auto *UI = Builder.CreateUnreachable();
+  Builder.SetInsertPoint(UI);
+
+  Value *CancelKind = nullptr;
+  switch (CanceledDirective) {
+#define OMP_CANCEL_KIND(Enum, Str, DirectiveEnum, Value)                       \
+  case DirectiveEnum:                                                          \
+    CancelKind = Builder.getInt32(Value);                                      \
+    break;
+#include "llvm/Frontend/OpenMP/OMPKinds.def"
+  default:
+    llvm_unreachable("Unknown cancel kind!");
+  }
+
+  uint32_t SrcLocStrSize;
+  Constant *SrcLocStr = getOrCreateSrcLocStr(Loc, SrcLocStrSize);
+  Value *Ident = getOrCreateIdent(SrcLocStr, SrcLocStrSize);
+  Value *Args[] = {Ident, getOrCreateThreadID(Ident), CancelKind};
+  Value *Result = Builder.CreateCall(
+      getOrCreateRuntimeFunctionPtr(OMPRTL___kmpc_cancellationpoint), Args);
+  auto ExitCB = [this, CanceledDirective, Loc](InsertPointTy IP) -> Error {
+    if (CanceledDirective == OMPD_parallel) {
+      IRBuilder<>::InsertPointGuard IPG(Builder);
+      Builder.restoreIP(IP);
+      return createBarrier(LocationDescription(Builder.saveIP(), Loc.DL),
+                           omp::Directive::OMPD_unknown,
+                           /* ForceSimpleCall */ false,
+                           /* CheckCancelFlag */ false)
+          .takeError();
+    }
+    return Error::success();
+  };
+
+  // The actual cancel logic is shared with others, e.g., cancel_barriers.
+  if (Error Err = emitCancelationCheckImpl(Result, CanceledDirective, ExitCB))
+    return Err;
+
+  // Update the insertion point and remove the terminator we introduced.
+  Builder.SetInsertPoint(UI->getParent());
+  UI->eraseFromParent();
+
+  return Builder.saveIP();
+}
+
 OpenMPIRBuilder::InsertPointTy OpenMPIRBuilder::emitTargetKernel(
     const LocationDescription &Loc, InsertPointTy AllocaIP, Value *&Return,
     Value *Ident, Value *DeviceID, Value *NumTeams, Value *NumThreads,
diff --git a/mlir/lib/Target/LLVMIR/Dialect/OpenMP/OpenMPToLLVMIRTranslation.cpp b/mlir/lib/Target/LLVMIR/Dialect/OpenMP/OpenMPToLLVMIRTranslation.cpp
index 16c93f902d9ec..11ac5e5bf1e7f 100644
--- a/mlir/lib/Target/LLVMIR/Dialect/OpenMP/OpenMPToLLVMIRTranslation.cpp
+++ b/mlir/lib/Target/LLVMIR/Dialect/OpenMP/OpenMPToLLVMIRTranslation.cpp
@@ -161,8 +161,7 @@ static LogicalResult checkImplementationStatus(Operation &op) {
   auto checkCancelDirective = [&todo](auto op, LogicalResult &result) {
     omp::ClauseCancellationConstructType cancelledDirective =
         op.getCancelDirective();
-    if (cancelledDirective != omp::ClauseCancellationConstructType::Parallel &&
-        cancelledDirective != omp::ClauseCancellationConstructType::Sections)
+    if (cancelledDirective == omp::ClauseCancellationConstructType::Taskgroup)
       result = todo("cancel directive construct type not yet supported");
   };
   auto checkDepend = [&todo](auto op, LogicalResult &result) {
@@ -256,6 +255,9 @@ static LogicalResult checkImplementationStatus(Operation &op) {
   LogicalResult result = success();
   llvm::TypeSwitch<Operation &>(op)
       .Case([&](omp::CancelOp op) { checkCancelDirective(op, result); })
+      .Case([&](omp::CancellationPointOp op) {
+        checkCancelDirective(op, result);
+      })
       .Case([&](omp::DistributeOp op) {
         checkAllocate(op, result);
         checkDistSchedule(op, result);
@@ -1590,11 +1592,12 @@ cleanupPrivateVars(llvm::IRBuilderBase &builder,
 
 /// Returns true if the construct contains omp.cancel or omp.cancellation_point
 static bool constructIsCancellable(Operation *op) {
-  // omp.cancel must be "closely nested" so it will be visible and not inside of
-  // funcion calls. This is enforced by the verifier.
+  // omp.cancel and omp.cancellation_point must be "closely nested" so they will
+  // be visible and not inside of function calls. This is enforced by the
+  // verifier.
   return op
       ->walk([](Operation *child) {
-        if (mlir::isa<omp::CancelOp>(child))
+        if (mlir::isa<omp::CancelOp, omp::CancellationPointOp>(child))
           return WalkResult::interrupt();
         return WalkResult::advance();
       })
@@ -2358,6 +2361,30 @@ convertOmpWsloop(Operation &opInst, llvm::IRBuilderBase &builder,
           ? llvm::omp::WorksharingLoopType::DistributeForStaticLoop
           : llvm::omp::WorksharingLoopType::ForStaticLoop;
 
+  SmallVector<llvm::BranchInst *> cancelTerminators;
+  // This callback is invoked only if there is cancellation inside of the wsloop
+  // body.
+  auto finiCB = [&](llvm::OpenMPIRBuilder::InsertPointTy ip) -> llvm::Error {
+    llvm::IRBuilderBase &llvmBuilder = ompBuilder->Builder;
+    llvm::IRBuilderBase::InsertPointGuard guard(llvmBuilder);
+
+    // ip is currently in the block branched to if cancellation occured.
+    // We need to create a branch to terminate that block.
+    llvmBuilder.restoreIP(ip);
+
+    // We must still clean up the wsloop after cancelling it, so we need to
+    // branch to the block that finalizes the wsloop.
+    // That block has not been created yet so use this block as a dummy for now
+    // and fix this after creating the wsloop.
+    cancelTerminators.push_back(llvmBuilder.CreateBr(ip.getBlock()));
+    return llvm::Error::success();
+  };
+  // We have to add the cleanup to the OpenMPIRBuilder before the body gets
+  // created in case the body contains omp.cancel (which will then expect to be
+  // able to find this cleanup callback).
+  ompBuilder->pushFinalizationCB({finiCB, llvm::omp::Directive::OMPD_for,
+                                  constructIsCancellable(wsloopOp)});
+
   llvm::OpenMPIRBuilder::LocationDescription ompLoc(builder);
   llvm::Expected<llvm::BasicBlock *> regionBlock = convertOmpOpRegions(
       wsloopOp.getRegion(), "omp.wsloop.region", builder, moduleTranslation);
@@ -2379,6 +2406,19 @@ convertOmpWsloop(Operation &opInst, llvm::IRBuilderBase &builder,
   if (failed(handleError(wsloopIP, opInst)))
     return failure();
 
+  ompBuilder->popFinalizationCB();
+  if (!cancelTerminators.empty()) {
+    // If we cancelled the loop, we should branch to the finalization block of
+    // the wsloop (which is always immediately before the loop continuation
+    // block). Now the finalization has been created, we can fix the branch.
+    llvm::BasicBlock *wsloopFini = wsloopIP->getBlock()->getSinglePredecessor();
+    for (llvm::BranchInst *cancelBranch : cancelTerminators) {
+      assert(cancelBranch->getNumSuccessors() == 1 &&
+             "cancel branch should have one target");
+      cancelBranch->setSuccessor(0, wsloopFini);
+    }
+  }
+
   // Process the reductions if required.
   if (failed(createReductionsAndCleanup(
           wsloopOp, builder, moduleTranslation, allocaIP, reductionDecls,
@@ -3056,6 +3096,30 @@ convertOmpCancel(omp::CancelOp op, llvm::IRBuilderBase &builder,
   return success();
 }
 
+static LogicalResult
+convertOmpCancellationPoint(omp::CancellationPointOp op,
+                            llvm::IRBuilderBase &builder,
+                            LLVM::ModuleTranslation &moduleTranslation) {
+  llvm::OpenMPIRBuilder::LocationDescription ompLoc(builder);
+  llvm::OpenMPIRBuilder *ompBuilder = moduleTranslation.getOpenMPBuilder();
+
+  if (failed(checkImplementationStatus(*op.getOperation())))
+    return failure();
+
+  llvm::omp::Directive cancelledDirective =
+      convertCancellationConstructType(op.getCancelDirective());
+
+  llvm::OpenMPIRBuilder::InsertPointOrErrorTy afterIP =
+      ompBuilder->createCancellationPoint(ompLoc, cancelledDirective);
+
+  if (failed(handleError(afterIP, *op.getOperation())))
+    return failure();
+
+  builder.restoreIP(afterIP.get());
+
+  return success();
+}
+
 /// Converts an OpenMP Threadprivate operation into LLVM IR using
 /// OpenMPIRBuilder.
 static LogicalResult
@@ -5489,6 +5553,9 @@ convertHostOrTargetOperation(Operation *op, llvm::IRBuilderBase &builder,
           .Case([&](omp::CancelOp op) {
             return convertOmpCancel(op, builder, moduleTranslation);
           })
+          .Case([&](omp::CancellationPointOp op) {
+            return convertOmpCancellationPoint(op, builder, moduleTranslation);
+          })
           .Case([&](omp::SectionsOp) {
             return convertOmpSections(*op, builder, moduleTranslation);
           })
diff --git a/mlir/test/Target/LLVMIR/openmp-cancel.mlir b/mlir/test/Target/LLVMIR/openmp-cancel.mlir
index fca16b936fc85..3c195a98d1000 100644
--- a/mlir/test/Target/LLVMIR/openmp-cancel.mlir
+++ b/mlir/test/Target/LLVMIR/openmp-cancel.mlir
@@ -156,3 +156,90 @@ llvm.func @cancel_sections_if(%cond : i1) {
 // CHECK:         ret void
 // CHECK:       .cncl:                                            ; preds = %[[VAL_27]]
 // CHECK:         br label %[[VAL_19]]
+
+llvm.func @cancel_wsloop_if(%lb : i32, %ub : i32, %step : i32, %cond : i1) {
+  omp.wsloop {
+    omp.loop_nest (%iv) : i32 = (%lb) to (%ub) step (%step) {
+      omp.cancel cancellation_construct_type(loop) if(%cond)
+      omp.yield
+    }
+  }
+  llvm.return
+}
+// CHECK-LABEL: define void @cancel_wsloop_if
+// CHECK:         %[[VAL_0:.*]] = alloca i32, align 4
+// CHECK:         %[[VAL_1:.*]] = alloca i32, align 4
+// CHECK:         %[[VAL_2:.*]] = alloca i32, align 4
+// CHECK:         %[[VAL_3:.*]] = alloca i32, align 4
+// CHECK:         br label %[[VAL_4:.*]]
+// CHECK:       omp.region.after_alloca:                          ; preds = %[[VAL_5:.*]]
+// CHECK:         br label %[[VAL_6:.*]]
+// CHECK:       entry:                                            ; preds = %[[VAL_4]]
+// CHECK:         br label %[[VAL_7:.*]]
+// CHECK:       omp.wsloop.region:                                ; preds = %[[VAL_6]]
+// CHECK:         %[[VAL_8:.*]] = icmp slt i32 %[[VAL_9:.*]], 0
+// CHECK:         %[[VAL_10:.*]] = sub i32 0, %[[VAL_9]]
+// CHECK:         %[[VAL_11:.*]] = select i1 %[[VAL_8]], i32 %[[VAL_10]], i32 %[[VAL_9]]
+// CHECK:         %[[VAL_12:.*]] = select i1 %[[VAL_8]], i32 %[[VAL_13:.*]], i32 %[[VAL_14:.*]]
+// CHECK:         %[[VAL_15:.*]] = select i1 %[[VAL_8]], i32 %[[VAL_14]], i32 %[[VAL_13]]
+// CHECK:         %[[VAL_16:.*]] = sub nsw i32 %[[VAL_15]], %[[VAL_12]]
+// CHECK:         %[[VAL_17:.*]] = icmp sle i32 %[[VAL_15]], %[[VAL_12]]
+// CHECK:         %[[VAL_18:.*]] = sub i32 %[[VAL_16]], 1
+// CHECK:         %[[VAL_19:.*]] = udiv i32 %[[VAL_18]], %[[VAL_11]]
+// CHECK:         %[[VAL_20:.*]] = add i32 %[[VAL_19]], 1
+// CHECK:         %[[VAL_21:.*]] = icmp ule i32 %[[VAL_16]], %[[VAL_11]]
+// CHECK:         %[[VAL_22:.*]] = select i1 %[[VAL_21]], i32 1, i32 %[[VAL_20]]
+// CHECK:         %[[VAL_23:.*]] = select i1 %[[VAL_17]], i32 0, i32 %[[VAL_22]]
+// CHECK:         br label %[[VAL_24:.*]]
+// CHECK:       omp_loop.preheader:                               ; preds = %[[VAL_7]]
+// CHECK:         store i32 0, ptr %[[VAL_1]], align 4
+// CHECK:         %[[VAL_25:.*]] = sub i32 %[[VAL_23]], 1
+// CHECK:         store i32 %[[VAL_25]], ptr %[[VAL_2]], align 4
+// CHECK:         store i32 1, ptr %[[VAL_3]], align 4
+// CHECK:         %[[VAL_26:.*]] = call i32 @__kmpc_global_thread_num(ptr @1)
+// CHECK:         call void @__kmpc_for_static_init_4u(ptr @1, i32 %[[VAL_26]], i32 34, ptr %[[VAL_0]], ptr %[[VAL_1]], ptr %[[VAL_2]], ptr %[[VAL_3]], i32 1, i32 0)
+// CHECK:         %[[VAL_27:.*]] = load i32, ptr %[[VAL_1]], align 4
+// CHECK:         %[[VAL_28:.*]] = load i32, ptr %[[VAL_2]], align 4
+// CHECK:         %[[VAL_29:.*]] = sub i32 %[[VAL_28]], %[[VAL_27]]
+// CHECK:         %[[VAL_30:.*]] = add i32 %[[VAL_29]], 1
+// CHECK:         br label %[[VAL_31:.*]]
+// CHECK:       omp_loop.header:                                  ; preds = %[[VAL_32:.*]], %[[VAL_24]]
+// CHECK:         %[[VAL_33:.*]] = phi i32 [ 0, %[[VAL_24]] ], [ %[[VAL_34:.*]], %[[VAL_32]] ]
+// CHECK:         br label %[[VAL_35:.*]]
+// CHECK:       omp_loop.cond:                                    ; preds = %[[VAL_31]]
+// CHECK:         %[[VAL_36:.*]] = icmp ult i32 %[[VAL_33]], %[[VAL_30]]
+// CHECK:         br i1 %[[VAL_36]], label %[[VAL_37:.*]], label %[[VAL_38:.*]]
+// CHECK:       omp_loop.body:                                    ; preds = %[[VAL_35]]
+// CHECK:         %[[VAL_39:.*]] = add i32 %[[VAL_33]], %[[VAL_27]]
+// CHECK:         %[[VAL_40:.*]] = mul i32 %[[VAL_39]], %[[VAL_9]]
+// CHECK:         %[[VAL_41:.*]] = add i32 %[[VAL_40]], %[[VAL_14]]
+// CHECK:         br label %[[VAL_42:.*]]
+// CHECK:       omp.loop_nest.region:                             ; preds = %[[VAL_37]]
+// CHECK:         br i1 %[[VAL_43:.*]], label %[[VAL_44:.*]], label %[[VAL_45:.*]]
+// CHECK:       25:                                               ; preds = %[[VAL_42]]
+// CHECK:         %[[VAL_46:.*]] = call i32 @__kmpc_global_thread_num(ptr @1)
+// CHECK:         %[[VAL_47:.*]] = call i32 @__kmpc_cancel(ptr @1, i32 %[[VAL_46]], i32 2)
+// CHECK:         %[[VAL_48:.*]] = icmp eq i32 %[[VAL_47]], 0
+// CHECK:         br i1 %[[VAL_48]], label %[[VAL_49:.*]], label %[[VAL_50:.*]]
+// CHECK:       .split:                                           ; preds = %[[VAL_44]]
+// CHECK:         br label %[[VAL_51:.*]]
+// CHECK:       28:                                               ; preds = %[[VAL_42]]
+// CHECK:         br label %[[VAL_51]]
+// CHECK:       29:                                               ; preds = %[[VAL_45]], %[[VAL_49]]
+// CHECK:         br label %[[VAL_52:.*]]
+// CHECK:       omp.region.cont1:                                 ; preds = %[[VAL_51]]
+// CHECK:         br label %[[VAL_32]]
+// CHECK:       omp_loop.inc:                                     ; preds = %[[VAL_52]]
+// CHECK:         %[[VAL_34]] = add nuw i32 %[[VAL_33]], 1
+// CHECK:         br label %[[VAL_31]]
+// CHECK:       omp_loop.exit:                                    ; preds = %[[VAL_50]], %[[VAL_35]]
+// CHECK:         call void @__kmpc_for_static_fini(ptr @1, i32 %[[VAL_26]])
+// CHECK:         %[[VAL_53:.*]] = call i32 @__kmpc_global_thread_num(ptr @1)
+// CHECK:         call void @__kmpc_barrier(ptr @2, i32 %[[VAL_53]])
+// CHECK:         br label %[[VAL_54:.*]]
+// CHECK:       omp_loop.after:                                   ; preds = %[[VAL_38]]
+// CHECK:         br label %[[VAL_55:.*]]
+// CHECK:       omp.region.cont:                                  ; preds = %[[VAL_54]]
+// CHECK:         ret void
+// CHECK:       .cncl:                                            ; preds = %[[VAL_44]]
+// CHECK:         br label %[[VAL_38]]
diff --git a/mlir/test/Target/LLVMIR/openmp-cancellation-point.mlir b/mlir/test/Target/LLVMIR/openmp-cancellation-point.mlir
new file mode 100644
index 0000000000000..bbb313c113567
--- /dev/null
+++ b/mlir/test/Target/LLVMIR/openmp-cancellation-point.mlir
@@ -0,0 +1,188 @@
+// RUN: mlir-translate --mlir-to-llvmir %s | FileCheck %s
+
+llvm.func @cancellation_point_parallel() {
+  omp.parallel {
+    omp.cancellation_point cancellation_construct_type(parallel)
+    omp.terminator
+  }
+  llvm.return
+}
+// CHECK-LABEL: define internal void @cancellation_point_parallel..omp_par
+// CHECK:       omp.par.entry:
+// CHECK:         %[[VAL_5:.*]] = alloca i32, align 4
+// CHECK:         %[[VAL_6:.*]] = load i32, ptr %[[VAL_7:.*]], align 4
+// CHECK:         store i32 %[[VAL_6]], ptr %[[VAL_5]], align 4
+// CHECK:         %[[VAL_8:.*]] = load i32, ptr %[[VAL_5]], align 4
+// CHECK:         br label %[[VAL_9:.*]]
+// CHECK:       omp.region.after_alloca:                          ; preds = %[[VAL_10:.*]]
+// CHECK:         br label %[[VAL_11:.*]]
+// CHECK:       omp.par.region:                                   ; preds = %[[VAL_9]]
+// CHECK:         br label %[[VAL_12:.*]]
+// CHECK:       omp.par.region1:                                  ; preds = %[[VAL_11]]
+// CHECK:         %[[VAL_13:.*]] = call i32 @__kmpc_global_thread_num(ptr @1)
+// CHECK:         %[[VAL_14:.*]] = call i32 @__kmpc_cancellationpoint(ptr @1, i32 %[[VAL_13]], i32 1)
+// CHECK:         %[[VAL_15:.*]] = icmp eq i32 %[[VAL_14]], 0
+// CHECK:         br i1 %[[VAL_15]], label %[[VAL_16:.*]], label %[[VAL_17:.*]]
+// CHECK:       omp.par.region1.cncl:                             ; preds = %[[VAL_12]]
+// CHECK:         %[[VAL_18:.*]] = call i32 @__kmpc_global_thread_num(ptr @1)
+// CHECK:         %[[VAL_19:.*]] = call i32 @__kmpc_cancel_barrier(ptr @2, i32 %[[VAL_18]])
+// CHECK:         br label %[[VAL_20:.*]]
+// CHECK:       omp.par.region1.split:                            ; preds = %[[VAL_12]]
+// CHECK:         br label %[[VAL_21:.*]]
+// CHECK:       omp.region.cont:                                  ; preds = %[[VAL_16]]
+// CHECK:         br label %[[VAL_22:.*]]
+// CHECK:       omp.par.pre_finalize:                             ; preds = %[[VAL_21]]
+// CHECK:         br label %[[VAL_20]]
+// CHECK:       omp.par.exit.exitStub:                            ; preds = %[[VAL_22]], %[[VAL_17]]
+// CHECK:         ret void
+
+llvm.func @cancellation_point_sections() {
+  omp.sections {
+    omp.section {
+      omp.cancellation_point cancellation_construct_type(sections)
+      omp.terminator
+    }
+    omp.terminator
+  }
+  llvm.return
+}
+// CHECK-LABEL: define void @cancellation_point_sections
+// CHECK:         %[[VAL_23:.*]] = alloca i32, align 4
+// CHECK:         %[[VAL_24:.*]] = alloca i32, align 4
+// CHECK:         %[[VAL_25:.*]] = alloca i32, align 4
+// CHECK:         %[[VAL_26:.*]] = alloca i32, align 4
+// CHECK:         br label %[[VAL_27:.*]]
+// CHECK:       entry:                                            ; preds = %[[VAL_28:.*]]
+// CHECK:         br label %[[VAL_29:.*]]
+// CHECK:       omp_section_loop.preheader:                       ; preds = %[[VAL_27]]
+// CHECK:         store i32 0, ptr %[[VAL_24]], align 4
+// CHECK:         store i32 0, ptr %[[VAL_25]], align 4
+// CHECK:         store i32 1, ptr %[[VAL_26]], align 4
+// CHECK:         %[[VAL_30:.*]] = call i32 @__kmpc_global_thread_num(ptr @1)
+// CHECK:         call void @__kmpc_for_static_init_4u(ptr @1, i32 %[[VAL_30]], i32 34, ptr %[[VAL_23]], ptr %[[VAL_24]], ptr %[[VAL_25]], ptr %[[VAL_26]], i32 1, i32 0)
+// CHECK:         %[[VAL_31:.*]] = load i32, ptr %[[VAL_24]], align 4
+// CHECK:         %[[VAL_32:.*]] = load i32, ptr %[[VAL_25]], align 4
+// CHECK:         %[[VAL_33:.*]] = sub i32 %[[VAL_32]], %[[VAL_31]]
+// CHECK:         %[[VAL_34:.*]] = add i32 %[[VAL_33]], 1
+// CHECK:         br label %[[VAL_35:.*]]
+// CHECK:       omp_section_loop.header:                          ; preds = %[[VAL_36:.*]], %[[VAL_29]]
+// CHECK:         %[[VAL_37:.*]] = phi i32 [ 0, %[[VAL_29]] ], [ %[[VAL_38:.*]], %[[VAL_36]] ]
+// CHECK:         br label %[[VAL_39:.*]]
+// CHECK:       omp_section_loop.cond:                            ; preds = %[[VAL_35]]
+// CHECK:         %[[VAL_40:.*]] = icmp ult i32 %[[VAL_37]], %[[VAL_34]]
+// CHECK:         br i1 %[[VAL_40]], label %[[VAL_41:.*]], label %[[VAL_42:.*]]
+// CHECK:       omp_section_loop.body:                            ; preds = %[[VAL_39]]
+// CHECK:         %[[VAL_43:.*]] = add i32 %[[VAL_37]], %[[VAL_31]]
+// CHECK:         %[[VAL_44:.*]] = mul i32 %[[VAL_43]], 1
+// CHECK:         %[[VAL_45:.*]] = add i32 %[[VAL_44]], 0
+// CHECK:         switch i32 %[[VAL_45]], label %[[VAL_46:.*]] [
+// CHECK:           i32 0, label %[[VAL_47:.*]]
+// CHECK:         ]
+// CHECK:       omp_section_loop.body.case:                       ; preds = %[[VAL_41]]
+// CHECK:         br label %[[VAL_48:.*]]
+// CHECK:       omp.section.region:                               ; preds = %[[VAL_47]]
+// CHECK:         %[[VAL_49:.*]] = call i32 @__kmpc_global_thread_num(ptr @1)
+// CHECK:         %[[VAL_50:.*]] = call i32 @__kmpc_cancellationpoint(ptr @1, i32 %[[VAL_49]], i32 3)
+// CHECK:         %[[VAL_51:.*]] = icmp eq i32 %[[VAL_50]], 0
+// CHECK:         br i1 %[[VAL_51]], label %[[VAL_52:.*]], label %[[VAL_53:.*]]
+// CHECK:       omp.section.region.split:                         ; preds = %[[VAL_48]]
+// CHECK:         br label %[[VAL_54:.*]]
+// CHECK:       omp.region.cont:                                  ; preds = %[[VAL_52]]
+// CHECK:         br label %[[VAL_46]]
+// CHECK:       omp_section_loop.body.sections.after:             ; preds = %[[VAL_54]], %[[VAL_41]]
+// CHECK:         br label %[[VAL_36]]
+// CHECK:       omp_section_loop.inc:                             ; preds = %[[VAL_46]]
+// CHECK:         %[[VAL_38]] = add nuw i32 %[[VAL_37]], 1
+// CHECK:         br label %[[VAL_35]]
+// CHECK:       omp_section_loop.exit:                            ; preds = %[[VAL_53]], %[[VAL_39]]
+// CHECK:         call void @__kmpc_for_static_fini(ptr @1, i32 %[[VAL_30]])
+// CHECK:         %[[VAL_55:.*]] = call i32 @__kmpc_global_thread_num(ptr @1)
+// CHECK:         call void @__kmpc_barrier(ptr @2, i32 %[[VAL_55]])
+// CHECK:         br label %[[VAL_56:.*]]
+// CHECK:       omp_section_loop.after:                           ; preds = %[[VAL_42]]
+// CHECK:         br label %[[VAL_57:.*]]
+// CHECK:       omp_section_loop.aftersections.fini:              ; preds = %[[VAL_56]]
+// CHECK:         ret void
+// CHECK:       omp.section.region.cncl:                          ; preds = %[[VAL_48]]
+// CHECK:         br label %[[VAL_42]]
+
+llvm.func @cancellation_point_wsloop(%lb : i32, %ub : i32, %step : i32) {
+  omp.wsloop {
+    omp.loop_nest (%iv) : i32 = (%lb) to (%ub) step (%step) {
+      omp.cancellation_point cancellation_construct_type(loop)
+      omp.yield
+    }
+  }
+  llvm.return
+}
+// CHECK-LABEL: define void @cancellation_point_wsloop
+// CHECK:         %[[VAL_58:.*]] = alloca i32, align 4
+// CHECK:         %[[VAL_59:.*]] = alloca i32, align 4
+// CHECK:         %[[VAL_60:.*]] = alloca i32, align 4
+// CHECK:         %[[VAL_61:.*]] = alloca i32, align 4
+// CHECK:         br label %[[VAL_62:.*]]
+// CHECK:       omp.region.after_alloca:                          ; preds = %[[VAL_63:.*]]
+// CHECK:         br label %[[VAL_64:.*]]
+// CHECK:       entry:                                            ; preds = %[[VAL_62]]
+// CHECK:         br label %[[VAL_65:.*]]
+// CHECK:       omp.wsloop.region:                                ; preds = %[[VAL_64]]
+// CHECK:         %[[VAL_66:.*]] = icmp slt i32 %[[VAL_67:.*]], 0
+// CHECK:         %[[VAL_68:.*]] = sub i32 0, %[[VAL_67]]
+// CHECK:         %[[VAL_69:.*]] = select i1 %[[VAL_66]], i32 %[[VAL_68]], i32 %[[VAL_67]]
+// CHECK:         %[[VAL_70:.*]] = select i1 %[[VAL_66]], i32 %[[VAL_71:.*]], i32 %[[VAL_72:.*]]
+// CHECK:         %[[VAL_73:.*]] = select i1 %[[VAL_66]], i32 %[[VAL_72]], i32 %[[VAL_71]]
+// CHECK:         %[[VAL_74:.*]] = sub nsw i32 %[[VAL_73]], %[[VAL_70]]
+// CHECK:         %[[VAL_75:.*]] = icmp sle i32 %[[VAL_73]], %[[VAL_70]]
+// CHECK:         %[[VAL_76:.*]] = sub i32 %[[VAL_74]], 1
+// CHECK:         %[[VAL_77:.*]] = udiv i32 %[[VAL_76]], %[[VAL_69]]
+// CHECK:         %[[VAL_78:.*]] = add i32 %[[VAL_77]], 1
+// CHECK:         %[[VAL_79:.*]] = icmp ule i32 %[[VAL_74]], %[[VAL_69]]
+// CHECK:         %[[VAL_80:.*]] = select i1 %[[VAL_79]], i32 1, i32 %[[VAL_78]]
+// CHECK:         %[[VAL_81:.*]] = select i1 %[[VAL_75]], i32 0, i32 %[[VAL_80]]
+// CHECK:         br label %[[VAL_82:.*]]
+// CHECK:       omp_loop.preheader:                               ; preds = %[[VAL_65]]
+// CHECK:         store i32 0, ptr %[[VAL_59]], align 4
+// CHECK:         %[[VAL_83:.*]] = sub i32 %[[VAL_81]], 1
+// CHECK:         store i32 %[[VAL_83]], ptr %[[VAL_60]], align 4
+// CHECK:         store i32 1, ptr %[[VAL_61]], align 4
+// CHECK:         %[[VAL_84:.*]] = call i32 @__kmpc_global_thread_num(ptr @1)
+// CHECK:         call void @__kmpc_for_static_init_4u(ptr @1, i32 %[[VAL_84]], i32 34, ptr %[[VAL_58]], ptr %[[VAL_59]], ptr %[[VAL_60]], ptr %[[VAL_61]], i32 1, i32 0)
+// CHECK:         %[[VAL_85:.*]] = load i32, ptr %[[VAL_59]], align 4
+// CHECK:         %[[VAL_86:.*]] = load i32, ptr %[[VAL_60]], align 4
+// CHECK:         %[[VAL_87:.*]] = sub i32 %[[VAL_86]], %[[VAL_85]]
+// CHECK:         %[[VAL_88:.*]] = add i32 %[[VAL_87]], 1
+// CHECK:         br label %[[VAL_89:.*]]
+// CHECK:       omp_loop.header:                                  ; preds = %[[VAL_90:.*]], %[[VAL_82]]
+// CHECK:         %[[VAL_91:.*]] = phi i32 [ 0, %[[VAL_82]] ], [ %[[VAL_92:.*]], %[[VAL_90]] ]
+// CHECK:         br label %[[VAL_93:.*]]
+// CHECK:       omp_loop.cond:                                    ; preds = %[[VAL_89]]
+// CHECK:         %[[VAL_94:.*]] = icmp ult i32 %[[VAL_91]], %[[VAL_88]]
+// CHECK:         br i1 %[[VAL_94]], label %[[VAL_95:.*]], label %[[VAL_96:.*]]
+// CHECK:       omp_loop.body:                                    ; preds = %[[VAL_93]]
+// CHECK:         %[[VAL_97:.*]] = add i32 %[[VAL_91]], %[[VAL_85]]
+// CHECK:         %[[VAL_98:.*]] = mul i32 %[[VAL_97]], %[[VAL_67]]
+// CHECK:         %[[VAL_99:.*]] = add i32 %[[VAL_98]], %[[VAL_72]]
+// CHECK:         br label %[[VAL_100:.*]]
+// CHECK:       omp.loop_nest.region:                             ; preds = %[[VAL_95]]
+// CHECK:         %[[VAL_101:.*]] = call i32 @__kmpc_global_thread_num(ptr @1)
+// CHECK:         %[[VAL_102:.*]] = call i32 @__kmpc_cancellationpoint(ptr @1, i32 %[[VAL_101]], i32 2)
+// CHECK:         %[[VAL_103:.*]] = icmp eq i32 %[[VAL_102]], 0
+// CHECK:         br i1 %[[VAL_103]], label %[[VAL_104:.*]], label %[[VAL_105:.*]]
+// CHECK:       omp.loop_nest.region.split:                       ; preds = %[[VAL_100]]
+// CHECK:         br label %[[VAL_106:.*]]
+// CHECK:       omp.region.cont1:                                 ; preds = %[[VAL_104]]
+// CHECK:         br label %[[VAL_90]]
+// CHECK:       omp_loop.inc:                                     ; preds = %[[VAL_106]]
+// CHECK:         %[[VAL_92]] = add nuw i32 %[[VAL_91]], 1
+// CHECK:         br label %[[VAL_89]]
+// CHECK:       omp_loop.exit:                                    ; preds = %[[VAL_105]], %[[VAL_93]]
+// CHECK:         call void @__kmpc_for_static_fini(ptr @1, i32 %[[VAL_84]])
+// CHECK:         %[[VAL_107:.*]] = call i32 @__kmpc_global_thread_num(ptr @1)
+// CHECK:         call void @__kmpc_barrier(ptr @2, i32 %[[VAL_107]])
+// CHECK:         br label %[[VAL_108:.*]]
+// CHECK:       omp_loop.after:                                   ; preds = %[[VAL_96]]
+// CHECK:         br label %[[VAL_109:.*]]
+// CHECK:       omp.region.cont:                                  ; preds = %[[VAL_108]]
+// CHECK:         ret void
+// CHECK:       omp.loop_nest.region.cncl:                        ; preds = %[[VAL_100]]
+// CHECK:         br label %[[VAL_96]]
diff --git a/mlir/test/Target/LLVMIR/openmp-todo.mlir b/mlir/test/Target/LLVMIR/openmp-todo.mlir
index 0cc96deacd954..789c0ad9ebb48 100644
--- a/mlir/test/Target/LLVMIR/openmp-todo.mlir
+++ b/mlir/test/Target/LLVMIR/openmp-todo.mlir
@@ -26,22 +26,6 @@ llvm.func @atomic_hint(%v : !llvm.ptr, %x : !llvm.ptr, %expr : i32) {
 
 // -----
 
-llvm.func @cancel_wsloop(%lb : i32, %ub : i32, %step: i32) {
-  // expected-error@below {{LLVM Translation failed for operation: omp.wsloop}}
-  omp.wsloop {
-    // expected-error@below {{LLVM Translation failed for operation: omp.loop_nest}}
-    omp.loop_nest (%iv) : i32 = (%lb) to (%ub) step (%step) {
-      // expected-error@below {{not yet implemented: Unhandled clause cancel directive construct type not yet supported in omp.cancel operation}}
-      // expected-error@below {{LLVM Translation failed for operation: omp.cancel}}
-      omp.cancel cancellation_construct_type(loop)
-      omp.yield
-    }
-  }
-  llvm.return
-}
-
-// -----
-
 llvm.func @cancel_taskgroup() {
   // expected-error@below {{LLVM Translation failed for operation: omp.taskgroup}}
   omp.taskgroup {
@@ -59,12 +43,16 @@ llvm.func @cancel_taskgroup() {
 
 // -----
 
-llvm.func @cancellation_point() {
-  // expected-error@below {{LLVM Translation failed for operation: omp.parallel}}
-  omp.parallel {
-    // expected-error@below {{not yet implemented: omp.cancellation_point}}
-    // expected-error@below {{LLVM Translation failed for operation: omp.cancellation_point}}
-    omp.cancellation_point cancellation_construct_type(parallel)
+llvm.func @cancellation_point_taskgroup() {
+  // expected-error@below {{LLVM Translation failed for operation: omp.taskgroup}}
+  omp.taskgroup {
+    // expected-error@below {{LLVM Translation failed for operation: omp.task}}
+    omp.task {
+      // expected-error@below {{not yet implemented: Unhandled clause cancel directive construct type not yet supported in omp.cancellation_point operation}}
+      // expected-error@below {{LLVM Translation failed for operation: omp.cancellation_point}}
+      omp.cancellation_point cancellation_construct_type(taskgroup)
+      omp.terminator
+    }
     omp.terminator
   }
   llvm.return
