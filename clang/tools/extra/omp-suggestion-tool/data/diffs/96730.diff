diff --git a/flang/lib/Lower/OpenMP/ClauseProcessor.cpp b/flang/lib/Lower/OpenMP/ClauseProcessor.cpp
index 9efff0523d972..0b4ecaac9d73c 100644
--- a/flang/lib/Lower/OpenMP/ClauseProcessor.cpp
+++ b/flang/lib/Lower/OpenMP/ClauseProcessor.cpp
@@ -394,6 +394,28 @@ bool ClauseProcessor::processNumThreads(
   return false;
 }
 
+bool ClauseProcessor::processOrder(mlir::omp::OrderClauseOps &result) const {
+  using Order = omp::clause::Order;
+  if (auto *clause = findUniqueClause<Order>()) {
+    fir::FirOpBuilder &firOpBuilder = converter.getFirOpBuilder();
+    result.orderAttr = mlir::omp::ClauseOrderKindAttr::get(
+        firOpBuilder.getContext(), mlir::omp::ClauseOrderKind::Concurrent);
+    const auto &modifier =
+        std::get<std::optional<Order::OrderModifier>>(clause->t);
+    if (modifier && *modifier == Order::OrderModifier::Unconstrained) {
+      result.orderModAttr = mlir::omp::OrderModifierAttr::get(
+          firOpBuilder.getContext(), mlir::omp::OrderModifier::unconstrained);
+    } else {
+      // "If order-modifier is not unconstrained, the behavior is as if the
+      // reproducible modifier is present."
+      result.orderModAttr = mlir::omp::OrderModifierAttr::get(
+          firOpBuilder.getContext(), mlir::omp::OrderModifier::reproducible);
+    }
+    return true;
+  }
+  return false;
+}
+
 bool ClauseProcessor::processOrdered(
     mlir::omp::OrderedClauseOps &result) const {
   if (auto *clause = findUniqueClause<omp::clause::Ordered>()) {
diff --git a/flang/lib/Lower/OpenMP/ClauseProcessor.h b/flang/lib/Lower/OpenMP/ClauseProcessor.h
index 5c9ab8baf82dd..53571ae5abc20 100644
--- a/flang/lib/Lower/OpenMP/ClauseProcessor.h
+++ b/flang/lib/Lower/OpenMP/ClauseProcessor.h
@@ -77,6 +77,7 @@ class ClauseProcessor {
                        mlir::omp::NumTeamsClauseOps &result) const;
   bool processNumThreads(lower::StatementContext &stmtCtx,
                          mlir::omp::NumThreadsClauseOps &result) const;
+  bool processOrder(mlir::omp::OrderClauseOps &result) const;
   bool processOrdered(mlir::omp::OrderedClauseOps &result) const;
   bool processPriority(lower::StatementContext &stmtCtx,
                        mlir::omp::PriorityClauseOps &result) const;
diff --git a/flang/lib/Lower/OpenMP/OpenMP.cpp b/flang/lib/Lower/OpenMP/OpenMP.cpp
index 23f27496091a5..0b33c2a62d388 100644
--- a/flang/lib/Lower/OpenMP/OpenMP.cpp
+++ b/flang/lib/Lower/OpenMP/OpenMP.cpp
@@ -1037,6 +1037,7 @@ static void genDistributeClauses(lower::AbstractConverter &converter,
   ClauseProcessor cp(converter, semaCtx, clauses);
   cp.processAllocate(clauseOps);
   cp.processDistSchedule(stmtCtx, clauseOps);
+  cp.processOrder(clauseOps);
   // TODO Support delayed privatization.
 }
 
@@ -1109,13 +1110,14 @@ static void genSimdClauses(lower::AbstractConverter &converter,
   ClauseProcessor cp(converter, semaCtx, clauses);
   cp.processAligned(clauseOps);
   cp.processIf(llvm::omp::Directive::OMPD_simd, clauseOps);
+  cp.processOrder(clauseOps);
   cp.processReduction(loc, clauseOps);
   cp.processSafelen(clauseOps);
   cp.processSimdlen(clauseOps);
 
   // TODO Support delayed privatization.
-  cp.processTODO<clause::Allocate, clause::Linear, clause::Nontemporal,
-                 clause::Order>(loc, llvm::omp::Directive::OMPD_simd);
+  cp.processTODO<clause::Allocate, clause::Linear, clause::Nontemporal>(
+      loc, llvm::omp::Directive::OMPD_simd);
 }
 
 static void genSingleClauses(lower::AbstractConverter &converter,
@@ -1280,12 +1282,13 @@ static void genWsloopClauses(
     llvm::SmallVectorImpl<const semantics::Symbol *> &reductionSyms) {
   ClauseProcessor cp(converter, semaCtx, clauses);
   cp.processNowait(clauseOps);
+  cp.processOrder(clauseOps);
   cp.processOrdered(clauseOps);
   cp.processReduction(loc, clauseOps, &reductionTypes, &reductionSyms);
   cp.processSchedule(stmtCtx, clauseOps);
   // TODO Support delayed privatization.
 
-  cp.processTODO<clause::Allocate, clause::Linear, clause::Order>(
+  cp.processTODO<clause::Allocate, clause::Linear>(
       loc, llvm::omp::Directive::OMPD_do);
 }
 
@@ -2023,8 +2026,8 @@ static void genCompositeDoSimd(lower::AbstractConverter &converter,
                                ConstructQueue::iterator item) {
   ClauseProcessor cp(converter, semaCtx, item->clauses);
   cp.processTODO<clause::Aligned, clause::Allocate, clause::Linear,
-                 clause::Order, clause::Safelen, clause::Simdlen>(
-      loc, llvm::omp::OMPD_do_simd);
+                 clause::Safelen, clause::Simdlen>(loc,
+                                                   llvm::omp::OMPD_do_simd);
   // TODO: Add support for vectorization - add vectorization hints inside loop
   // body.
   // OpenMP standard does not specify the length of vector instructions.
diff --git a/flang/test/Lower/OpenMP/order-clause.f90 b/flang/test/Lower/OpenMP/order-clause.f90
new file mode 100644
index 0000000000000..717d9740c56f8
--- /dev/null
+++ b/flang/test/Lower/OpenMP/order-clause.f90
@@ -0,0 +1,76 @@
+! This test checks lowering of OpenMP order clause.
+
+!RUN: %flang_fc1 -emit-hlfir -fopenmp -fopenmp-version=50 %s -o - | FileCheck %s
+
+!CHECK-LABEL:   func.func @_QPsimd_order() {
+subroutine simd_order
+   !CHECK: omp.simd order(reproducible:concurrent) {
+   !$omp simd order(concurrent)
+   do i = 1, 10
+   end do
+   !CHECK: omp.simd order(reproducible:concurrent) {
+   !$omp simd order(reproducible:concurrent)
+   do i = 1, 10
+   end do
+   !CHECK: omp.simd order(unconstrained:concurrent) {
+   !$omp simd order(unconstrained:concurrent)
+   do i = 1, 10
+   end do
+end subroutine simd_order
+
+!CHECK-LABEL:   func.func @_QPdo_order() {
+subroutine do_order
+   !CHECK: omp.wsloop order(reproducible:concurrent) {
+   !$omp do order(concurrent)
+   do i = 1, 10
+   end do
+   !CHECK: omp.wsloop order(reproducible:concurrent) {
+   !$omp do order(reproducible:concurrent)
+   do i = 1, 10
+   end do
+   !CHECK: omp.wsloop order(unconstrained:concurrent) {
+   !$omp do order(unconstrained:concurrent)
+   do i = 1, 10
+   end do
+end subroutine do_order
+
+!CHECK-LABEL:   func.func @_QPdo_simd_order() {
+subroutine do_simd_order
+   !CHECK: omp.wsloop order(reproducible:concurrent) {
+   !$omp do simd order(concurrent)
+   do i = 1, 10
+   end do
+   !CHECK: omp.wsloop order(reproducible:concurrent) {
+   !$omp do simd order(reproducible:concurrent)
+   do i = 1, 10
+   end do
+   !CHECK: omp.wsloop order(unconstrained:concurrent) {
+   !$omp do simd order(unconstrained:concurrent)
+   do i = 1, 10
+   end do
+end subroutine do_simd_order
+
+!CHECK-LABEL:   func.func @_QPdo_simd_order_parallel() {
+subroutine do_simd_order_parallel
+   !CHECK: omp.parallel {
+   !CHECK: omp.wsloop order(reproducible:concurrent) {
+   !$omp parallel do simd order(reproducible:concurrent)
+   do i = 1, 10
+   end do
+end subroutine do_simd_order_parallel
+
+
+subroutine distribute_order
+   !CHECK: omp.distribute order(reproducible:concurrent) {
+   !$omp teams distribute order(concurrent)
+   do i=1,10
+   end do
+   !CHECK: omp.distribute order(reproducible:concurrent) {
+   !$omp teams distribute order(reproducible:concurrent)
+   do i=1,10
+   end do
+   !CHECK: omp.distribute order(unconstrained:concurrent) {
+   !$omp teams distribute order(unconstrained:concurrent)
+   do i = 1, 10
+   end do
+end subroutine
diff --git a/llvm/include/llvm/Frontend/OpenMP/OMP.td b/llvm/include/llvm/Frontend/OpenMP/OMP.td
index c818448d3d190..005c678302b27 100644
--- a/llvm/include/llvm/Frontend/OpenMP/OMP.td
+++ b/llvm/include/llvm/Frontend/OpenMP/OMP.td
@@ -665,6 +665,7 @@ def OMP_Distribute : Directive<"distribute"> {
   let allowedOnceClauses = [
     VersionedClause<OMPC_Collapse>,
     VersionedClause<OMPC_DistSchedule>,
+    VersionedClause<OMPC_Order, 50>,
   ];
   let association = AS_Loop;
   let category = CA_Executable;
@@ -2057,6 +2058,7 @@ def OMP_TargetTeamsDistribute : Directive<"target teams distribute"> {
     VersionedClause<OMPC_NoWait>,
     VersionedClause<OMPC_NumTeams>,
     VersionedClause<OMPC_OMPX_DynCGroupMem>,
+    VersionedClause<OMPC_Order, 50>,
     VersionedClause<OMPC_ThreadLimit>,
   ];
   let leafConstructs = [OMP_Target, OMP_Teams, OMP_Distribute];
@@ -2330,6 +2332,7 @@ def OMP_TeamsDistribute : Directive<"teams distribute"> {
   ];
   let allowedOnceClauses = [
     VersionedClause<OMPC_If>,
+    VersionedClause<OMPC_Order, 50>,
   ];
   let leafConstructs = [OMP_Teams, OMP_Distribute];
   let category = CA_Executable;
diff --git a/llvm/unittests/Frontend/OpenMPDecompositionTest.cpp b/llvm/unittests/Frontend/OpenMPDecompositionTest.cpp
index c68d9e423e7ba..c70341b5a86d2 100644
--- a/llvm/unittests/Frontend/OpenMPDecompositionTest.cpp
+++ b/llvm/unittests/Frontend/OpenMPDecompositionTest.cpp
@@ -688,8 +688,7 @@ TEST_F(OpenMPDecompositionTest, Order1) {
   std::string Dir5 = stringify(Dec.output[5]);
   ASSERT_EQ(Dir0, "target"); // (31)
   ASSERT_EQ(Dir1, "teams");  // (31)
-  // XXX OMP.td doesn't list "order" as allowed for "distribute"
-  ASSERT_EQ(Dir2, "distribute");       // (31)
+  ASSERT_EQ(Dir2, "distribute order(1, 0)"); // (31)
   ASSERT_EQ(Dir3, "parallel");         // (31)
   ASSERT_EQ(Dir4, "for order(1, 0)");  // (31)
   ASSERT_EQ(Dir5, "simd order(1, 0)"); // (31)
